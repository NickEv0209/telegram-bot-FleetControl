"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramClient = void 0;
const axios_1 = __importDefault(require("axios"));
const deep_extend_1 = __importDefault(require("deep-extend"));
const p_timeout_1 = __importDefault(require("p-timeout"));
const util_1 = require("util");
const delay = (0, util_1.promisify)(setTimeout);
class TelegramClient {
    constructor(url, botToken, options = {}) {
        this.userId = options.userId || 1;
        this.timeout = options.timeout || 1000;
        this.interval = options.interval || 100;
        this.chatId = options.chatId || 1;
        this.chatTitle = options.chatTitle || options.firstName || 'Test Name';
        this.firstName = options.firstName || 'TestName';
        this.userName = options.userName || 'testUserName';
        this.type = options.type || 'private';
        if (url === undefined) {
            throw new Error('Please define telegram api URL');
        }
        if (botToken === undefined) {
            throw new Error('Please define bot token');
        }
        this.url = url;
        this.botToken = botToken;
    }
    makeMessage(messageText, options = {}) {
        return (0, deep_extend_1.default)(Object.assign(Object.assign(Object.assign({}, this.makeCommonMessage()), this.getMessageMeta()), { text: messageText }), options);
    }
    makeCommand(messageText, options = {}) {
        const entityOffset = (messageText.includes('/') && messageText.indexOf('/')) || 0;
        const entityLength = (messageText.includes(' ') && messageText.indexOf(' ') - entityOffset)
            || messageText.length;
        const entities = [
            {
                offset: entityOffset,
                length: entityLength,
                type: 'bot_command',
            },
        ];
        return (0, deep_extend_1.default)(Object.assign(Object.assign(Object.assign({}, this.makeCommonMessage()), this.getMessageMeta()), { text: messageText, entities }), options);
    }
    makeCallbackQuery(data, options = {}) {
        const message = this.makeCommonMessage();
        return (0, deep_extend_1.default)(Object.assign(Object.assign({}, this.getMessageMeta()), { from: message.from, message,
            data }), options);
    }
    makeCommonMessage() {
        return {
            from: {
                id: this.userId,
                first_name: this.firstName,
                username: this.userName,
                is_bot: false,
            },
            chat: {
                id: this.chatId,
                title: this.chatTitle,
                first_name: this.firstName,
                username: this.userName,
                type: this.type,
            },
        };
    }
    getMessageMeta() {
        return {
            botToken: this.botToken,
            date: Math.floor(Date.now() / 1000),
        };
    }
    async sendMessage(message) {
        const res = await (0, axios_1.default)({
            url: `${this.url}/sendMessage`,
            method: 'POST',
            data: message,
        });
        return res && res.data;
    }
    async sendCommand(message) {
        const res = await (0, axios_1.default)({
            url: `${this.url}/sendCommand`,
            method: 'POST',
            data: message,
        });
        return res && res.data;
    }
    async sendCallback(message) {
        const res = await (0, axios_1.default)({
            url: `${this.url}/sendCallback`,
            method: 'POST',
            data: message,
        });
        return res && res.data;
    }
    async getUpdates() {
        const data = { token: this.botToken, chatId: this.chatId };
        const update = await (0, axios_1.default)({
            url: `${this.url}/getUpdates`,
            method: 'POST',
            data,
        });
        if (update.data
            && update.data.result !== undefined
            && update.data.result.length >= 1) {
            return update.data;
        }
        await delay(this.interval);
        return (0, p_timeout_1.default)(this.getUpdates(), this.timeout, `did not get new updates in ${this.timeout} ms`);
    }
    async getUpdatesHistory() {
        const data = { token: this.botToken };
        const res = await (0, axios_1.default)({
            url: `${this.url}/getUpdatesHistory`,
            method: 'POST',
            data,
        });
        return res.data && res.data.result;
    }
}
exports.TelegramClient = TelegramClient;
