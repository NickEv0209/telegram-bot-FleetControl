"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleterBot = exports.CallbackQBot = exports.TelegramBotEx = exports.attachMessageHandler = exports.Logger = void 0;
const debug_1 = __importDefault(require("debug"));
const node_telegram_bot_api_1 = __importDefault(require("node-telegram-bot-api"));
const debugServerUpdate = (0, debug_1.default)('TelegramServer:test:serverUpdate');
const debugBotMessage = (0, debug_1.default)('TelegramServer:test:botMessage');
class Logger {
    static serverUpdate(...args) {
        debugServerUpdate(JSON.stringify(args));
    }
    static botMessages(...args) {
        debugBotMessage(JSON.stringify(args));
    }
}
exports.Logger = Logger;
function attachMessageHandler(bot) {
    bot.onText(/\/ping/, (msg) => {
        const chatId = msg.chat.id;
        if (!chatId)
            return;
        const opts = {
            reply_to_message_id: msg.message_id,
            reply_markup: {
                keyboard: [[{ text: 'ok 1' }]],
            },
        };
        bot.sendMessage(chatId, 'pong', opts);
    });
    bot.onText(/\/start/, (msg) => {
        const chatId = msg.chat.id;
        if (!chatId)
            return;
        const opts = {
            reply_to_message_id: msg.message_id,
            reply_markup: {
                keyboard: [[{ text: 'Masha' }, { text: 'Sasha' }]],
            },
        };
        bot.sendMessage(chatId, 'What is your name?', opts);
    });
    bot.onText(/Masha/, (msg) => {
        const chatId = msg.chat.id;
        if (!chatId)
            return;
        const opts = {
            reply_to_message_id: msg.message_id,
            reply_markup: {
                keyboard: [[{ text: 'Hello!' }]],
            },
        };
        bot.sendMessage(chatId, 'Hello, Masha!', opts);
    });
    bot.onText(/Sasha/, (msg) => {
        const chatId = msg.chat.id;
        if (!chatId)
            return;
        const opts = {
            reply_to_message_id: msg.message_id,
            reply_markup: {
                keyboard: [[{ text: 'Hello!' }]],
            },
        };
        bot.sendMessage(chatId, 'Hello, Sasha!', opts);
    });
}
exports.attachMessageHandler = attachMessageHandler;
class TelegramBotEx extends node_telegram_bot_api_1.default {
    waitForReceiveUpdate() {
        return new Promise((resolve) => {
            this.on('message', (msg) => {
                Logger.serverUpdate(msg);
                resolve(msg);
            });
        });
    }
}
exports.TelegramBotEx = TelegramBotEx;
class CallbackQBot extends node_telegram_bot_api_1.default {
    waitForReceiveUpdate() {
        return new Promise((resolve) => {
            this.on('callback_query', (cb) => {
                Logger.serverUpdate(cb);
                resolve(cb);
            });
        });
    }
}
exports.CallbackQBot = CallbackQBot;
class DeleterBot extends node_telegram_bot_api_1.default {
    constructor(token, options) {
        super(token, options);
        this.onText(/delete/, (msg) => {
            const chatId = msg.chat.id;
            this.deleteMessage(chatId, String(msg.message_id));
        });
    }
}
exports.DeleterBot = DeleterBot;
