"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const chai_1 = require("chai");
const node_telegram_bot_api_1 = __importDefault(require("node-telegram-bot-api"));
const utils_1 = require("./utils");
const testBots_1 = require("./testBots");
const debugTest = (0, debug_1.default)('TelegramServer:test');
function isReplyKeyboard(markup) {
    return markup !== undefined && 'keyboard' in markup;
}
function isInlineKeyboard(markup) {
    return markup !== undefined && 'inline_keyboard' in markup;
}
function isCommonButton(btn) {
    return typeof btn === 'object' && btn !== null && 'text' in btn;
}
function isBotUpdate(upd) {
    return upd !== undefined && 'message' in upd;
}
describe('Telegram Server', () => {
    const token = 'sampleToken';
    it('should receive user`s messages', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const message = client.makeMessage('/start');
        const res = await client.sendMessage(message);
        await server.stop();
        chai_1.assert.equal(true, res.ok);
    });
    it('should provide user messages to bot', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const message = client.makeMessage('/start');
        const res = await client.sendMessage(message);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        const res2 = await telegramBot.waitForReceiveUpdate();
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await server.stop();
        chai_1.assert.equal('/start', res2.text);
    });
    it('should receive bot`s messages', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const message = client.makeMessage('/start');
        const botWaiter = server.waitBotMessage();
        const res = await client.sendMessage(message);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        (0, testBots_1.attachMessageHandler)(telegramBot);
        const res2 = await telegramBot.waitForReceiveUpdate();
        chai_1.assert.equal('/start', res2.text);
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await botWaiter;
        testBots_1.Logger.botMessages(server.storage);
        chai_1.assert.equal(1, server.storage.botMessages.length, 'Message queue should contain one message!');
        await server.stop();
    });
    it('should provide bot`s messages to client', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const message = client.makeMessage('/start');
        const botWaiter = server.waitBotMessage();
        const res = await client.sendMessage(message);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        (0, testBots_1.attachMessageHandler)(telegramBot);
        const res2 = await telegramBot.waitForReceiveUpdate();
        chai_1.assert.equal('/start', res2.text);
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await botWaiter;
        const updates = await client.getUpdates();
        testBots_1.Logger.serverUpdate(updates.result);
        chai_1.assert.equal(1, updates.result.length, 'Updates queue should contain one message!');
        await server.stop();
    });
    it('should message in response to /sendMessage', (done) => {
        (0, utils_1.getServerAndClient)(token).then(({ server, client }) => {
            const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
            const bot = new node_telegram_bot_api_1.default(token, botOptions);
            bot.onText(/\/start/, async (msg) => {
                const chatId = msg.chat.id;
                if (!chatId)
                    return;
                const reply = await bot.sendMessage(chatId, 'ololo #azaza', {
                    reply_to_message_id: msg.message_id,
                    reply_markup: {
                        inline_keyboard: [[{ text: 'foo', callback_data: 'bar' }]],
                    },
                });
                const update = server.getUpdatesHistory(token).find((upd) => reply.message_id === upd.messageId);
                if (!isBotUpdate(update)) {
                    chai_1.assert.fail('Cannot find bot update with messageId porvided in response');
                }
                chai_1.assert.equal(update.message.text, reply.text);
                if (!isInlineKeyboard(update.message.reply_markup)) {
                    chai_1.assert.fail('Wrong keyboard type in stored update');
                }
                chai_1.assert.deepEqual(reply.reply_markup, update.message.reply_markup);
                await server.stop();
                await bot.stopPolling();
                done();
            });
            return client.sendMessage(client.makeMessage('/start'));
        }).catch((err) => chai_1.assert.fail(err));
    });
    it('waits user message', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        client.sendCommand(client.makeCommand('/start'));
        await server.waitUserMessage();
        const history = await client.getUpdatesHistory();
        chai_1.assert.equal(history.length, 1);
        await server.stop();
    });
    it('should fully implement user-bot interaction', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        let message = client.makeMessage('/start');
        const res = await client.sendMessage(message);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        (0, testBots_1.attachMessageHandler)(telegramBot);
        const updates = await client.getUpdates();
        testBots_1.Logger.serverUpdate(updates.result);
        chai_1.assert.equal(1, updates.result.length, 'Updates queue should contain one message!');
        const markup = updates.result[0].message.reply_markup;
        if (!isReplyKeyboard(markup) || !isCommonButton(markup.keyboard[0][0])) {
            throw new Error('No keyboard in update');
        }
        message = client.makeMessage(markup.keyboard[0][0].text);
        await client.sendMessage(message);
        const updates2 = await client.getUpdates();
        testBots_1.Logger.serverUpdate(updates2.result);
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await server.stop();
        chai_1.assert.equal(1, updates2.result.length, 'Updates queue should contain one message!');
        chai_1.assert.equal('Hello, Masha!', updates2.result[0].message.text, 'Wrong greeting message!');
    });
    it('should get updates only for respective client', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        (0, testBots_1.attachMessageHandler)(telegramBot);
        const client2 = server.getClient(token, { chatId: 2, firstName: 'Second User' });
        await client.sendMessage(client.makeMessage('/start'));
        await client2.sendMessage(client2.makeMessage('/start'));
        const updates = await client.getUpdates();
        const updates2 = await client2.getUpdates();
        chai_1.assert.equal(updates.result.length, 1);
        chai_1.assert.equal(updates2.result.length, 1);
        await telegramBot.stopPolling();
        await server.stop();
    });
    it('should get updates history', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        let message = client.makeMessage('/start');
        const res = await client.sendMessage(message);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.TelegramBotEx(token, botOptions);
        (0, testBots_1.attachMessageHandler)(telegramBot);
        const updates = await client.getUpdates();
        testBots_1.Logger.serverUpdate(updates.result);
        chai_1.assert.equal(1, updates.result.length, 'Updates queue should contain one message!');
        const markup = updates.result[0].message.reply_markup;
        if (!isReplyKeyboard(markup) || !isCommonButton(markup.keyboard[0][0])) {
            throw new Error('No keyboard in update');
        }
        message = client.makeMessage(markup.keyboard[0][0].text);
        await client.sendMessage(message);
        const updates2 = await client.getUpdates();
        testBots_1.Logger.serverUpdate(updates2.result);
        chai_1.assert.equal(1, updates2.result.length, 'Updates queue should contain one message!');
        chai_1.assert.equal('Hello, Masha!', updates2.result[0].message.text, 'Wrong greeting message!');
        const history = await client.getUpdatesHistory();
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await server.stop();
        chai_1.assert.equal(history.length, 4);
        history.forEach((item, index) => {
            chai_1.assert.ok(item.time);
            chai_1.assert.ok(item.botToken);
            chai_1.assert.ok('message' in item && item.message);
            chai_1.assert.ok(item.updateId);
            chai_1.assert.ok(item.messageId);
            if (index > 0) {
                chai_1.assert.isAbove(item.time, history[index - 1].time);
            }
        });
    });
    it('should allow messages deletion', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.DeleterBot(token, botOptions);
        let message = client.makeMessage('delete');
        const res = await client.sendMessage(message);
        chai_1.assert.ok(res.ok);
        message = client.makeMessage('keep safe');
        const res2 = await client.sendMessage(message);
        chai_1.assert.ok(res2.ok);
        await (0, utils_1.assertEventuallyTrue)(500, 'User messages count should become 1', () => server.storage.userMessages.length === 1);
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        await server.stop();
    });
    it('should receive user`s callbacks', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const cb = client.makeCallbackQuery('somedata');
        const res = await client.sendCallback(cb);
        await server.stop();
        chai_1.assert.equal(true, res.ok);
    });
    it('should provide user`s callbacks to bot', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const cb = client.makeCallbackQuery('somedata');
        const res = await client.sendCallback(cb);
        chai_1.assert.equal(true, res.ok);
        const botOptions = { polling: true, baseApiUrl: server.config.apiURL };
        const telegramBot = new testBots_1.CallbackQBot(token, botOptions);
        const res2 = await telegramBot.waitForReceiveUpdate();
        debugTest('Stopping polling');
        await telegramBot.stopPolling();
        debugTest('Polling stopped');
        await server.stop();
        chai_1.assert.equal('somedata', res2.data);
    });
    it('should handle message editing', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token);
        const bot = new node_telegram_bot_api_1.default(token, { baseApiUrl: server.config.apiURL, polling: true });
        bot.onText(/\/start/, (msg) => {
            const chatId = msg.from.id;
            bot.sendMessage(chatId, 'Greetings');
        });
        bot.on('callback_query', (query) => {
            if (query.data === 'edit') {
                bot.editMessageText('Edited', { chat_id: query.message.chat.id, message_id: query.message.message_id });
            }
        });
        await client.sendCommand(client.makeCommand('/start'));
        const startUpdates = await client.getUpdates();
        const botReply = startUpdates.result[0];
        chai_1.assert.exists(botReply);
        chai_1.assert.equal(botReply.message.text, 'Greetings');
        const cb = client.makeCallbackQuery('edit', { message: { message_id: botReply.messageId } });
        await client.sendCallback(cb);
        await server.waitBotEdits();
        const allUpdates = await client.getUpdatesHistory();
        const targetUpdte = allUpdates.find((update) => update.messageId === botReply.messageId);
        chai_1.assert.equal(targetUpdte && 'message' in targetUpdte && targetUpdte.message.text, 'Edited');
        await bot.stopPolling();
        await server.stop();
    });
    it('should remove messages on storeTimeout', async () => {
        const { server, client } = await (0, utils_1.getServerAndClient)(token, {
            storeTimeout: 1,
        });
        const message = client.makeMessage('/start');
        await client.sendMessage(message);
        chai_1.assert.equal(server.storage.userMessages.length, 1);
        debugTest('equal 1 ok');
        await (0, utils_1.delay)(2100);
        debugTest('waited for delay');
        debugTest('server.storage.userMessages', server.storage.userMessages);
        chai_1.assert.equal(server.storage.userMessages.length, 0);
        await server.stop();
    });
});
