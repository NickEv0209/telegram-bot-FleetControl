"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramServer = void 0;
const assert_1 = __importDefault(require("assert"));
const axios_1 = __importDefault(require("axios"));
const debug_1 = __importDefault(require("debug"));
const events_1 = __importDefault(require("events"));
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const http_shutdown_1 = __importDefault(require("http-shutdown"));
const requestLogger_1 = require("./modules/requestLogger");
const sendResult_1 = require("./modules/sendResult");
const telegramClient_1 = require("./modules/telegramClient");
const index_1 = require("./routes/index");
const debugServer = (0, debug_1.default)('TelegramServer:server');
const debugStorage = (0, debug_1.default)('TelegramServer:storage');
class TelegramServer extends events_1.default {
    constructor(config = {}) {
        super();
        this.started = false;
        this.updateId = 1;
        this.messageId = 1;
        this.callbackId = 1;
        this.storage = {
            userMessages: [],
            botMessages: [],
        };
        this.cleanUpDaemonInterval = null;
        this.server = null;
        this.webhooks = {};
        this.config = TelegramServer.normalizeConfig(config);
        debugServer(`Telegram API server config: ${JSON.stringify(this.config)}`);
        this.webServer = (0, express_1.default)();
        this.webServer.use(sendResult_1.sendResult);
        this.webServer.use(express_1.default.json());
        this.webServer.use(express_1.default.urlencoded({ extended: true }));
        this.webServer.use(requestLogger_1.requestLogger);
        if (this.config.storage === 'RAM') {
            this.storage = {
                userMessages: [],
                botMessages: [],
            };
        }
        for (let i = 0; i < index_1.routes.length; i++) {
            index_1.routes[i](this.webServer, this);
        }
        this.webServer.use((_req, res) => {
            res.sendError(new Error('Route not found'));
        });
        const globalErrorHandler = (error, _req, res, _next) => {
            debugServer(`Error: ${error}`);
            res.sendError(new Error(`Something went wrong. ${error}`));
        };
        this.webServer.use(globalErrorHandler);
    }
    static normalizeConfig(config) {
        const appConfig = {
            port: config.port || 9000,
            host: config.host || 'localhost',
            protocol: config.protocol || 'http',
            storage: config.storage || 'RAM',
            storeTimeout: (config.storeTimeout || 60) * 1000,
            apiURL: '',
        };
        appConfig.apiURL = `${appConfig.protocol}://${appConfig.host}:${appConfig.port}`;
        return appConfig;
    }
    getClient(botToken, options) {
        return new telegramClient_1.TelegramClient(this.config.apiURL, botToken, options);
    }
    addBotMessage(rawMessage, botToken) {
        const d = new Date();
        const millis = d.getTime();
        const message = TelegramServer.normalizeMessage(rawMessage);
        const add = {
            time: millis,
            botToken,
            message,
            updateId: this.updateId,
            messageId: this.messageId,
            isRead: false,
        };
        this.storage.botMessages.push(add);
        let inlineMarkup;
        if (message.reply_markup && 'inline_keyboard' in message.reply_markup) {
            inlineMarkup = message.reply_markup;
        }
        const msg = Object.assign(Object.assign({}, message), { reply_markup: inlineMarkup, message_id: this.messageId, date: add.time, text: message.text, chat: {
                id: Number(message.chat_id),
                first_name: 'Bot',
                type: 'private',
            } });
        this.messageId++;
        this.updateId++;
        this.emit('AddedBotMessage');
        return msg;
    }
    editMessageText(rawMessage) {
        const message = TelegramServer.normalizeMessage(rawMessage);
        const update = this.storage.botMessages.find((u) => (String(u.messageId) === String(message.message_id)
            && String(u.message.chat_id) === String(message.chat_id)));
        if (update) {
            update.message = Object.assign(Object.assign({}, update.message), message);
            this.emit('EditedMessageText');
        }
    }
    async waitBotEdits() {
        return new Promise((resolve) => {
            this.once('EditedMessageText', () => resolve());
        });
    }
    async waitBotMessage() {
        return new Promise((resolve) => {
            this.once('AddedBotMessage', () => resolve());
        });
    }
    async waitUserMessage() {
        return new Promise((resolve) => {
            const messageHandler = () => {
                this.off('AddedUserMessage', messageHandler);
                this.off('AddedUserCommand', messageHandler);
                this.off('AddedUserCallbackQuery', messageHandler);
                resolve();
            };
            this.on('AddedUserMessage', messageHandler);
            this.on('AddedUserCommand', messageHandler);
            this.on('AddedUserCallbackQuery', messageHandler);
        });
    }
    async addUserMessage(message) {
        await this.addUserUpdate(Object.assign(Object.assign({}, this.getCommonFields(message.botToken)), { message }));
        this.messageId++;
        this.emit('AddedUserMessage');
    }
    async addUserCommand(message) {
        assert_1.default.ok(message.entities, 'Command should have entities');
        await this.addUserUpdate(Object.assign(Object.assign({}, this.getCommonFields(message.botToken)), { message, entities: message.entities }));
        this.messageId++;
        this.emit('AddedUserCommand');
    }
    async addUserCallback(callbackQuery) {
        await this.addUserUpdate(Object.assign(Object.assign({}, this.getCommonFields(callbackQuery.botToken)), { callbackQuery, callbackId: this.callbackId }));
        this.callbackId++;
        this.emit('AddedUserCallbackQuery');
    }
    getCommonFields(botToken) {
        const d = new Date();
        const millis = d.getTime();
        return {
            time: millis,
            botToken,
            updateId: this.updateId,
            messageId: this.messageId,
            isRead: false,
        };
    }
    async addUserUpdate(update) {
        assert_1.default.ok(update.botToken, 'The message must be of type object and must contain `botToken` field.');
        const webhook = this.webhooks[update.botToken];
        if (webhook) {
            const resp = await (0, axios_1.default)({
                url: webhook.url,
                method: 'POST',
                data: TelegramServer.formatUpdate(update),
            });
            if (resp.status > 204) {
                debugServer(`Webhook invocation failed: ${JSON.stringify({
                    url: webhook.url,
                    method: 'POST',
                    requestBody: update,
                    responseStatus: resp.status,
                    responseBody: resp.data,
                })}`);
                throw new Error('Webhook invocation failed');
            }
        }
        else {
            this.storage.userMessages.push(update);
        }
        this.updateId++;
    }
    messageFilter(message) {
        const d = new Date();
        const millis = d.getTime();
        return message.time > millis - this.config.storeTimeout;
    }
    cleanUp() {
        debugStorage('clearing storage');
        debugStorage(`current userMessages storage: ${this.storage.userMessages.length}`);
        this.storage.userMessages = this.storage.userMessages.filter(this.messageFilter, this);
        debugStorage(`filtered userMessages storage: ${this.storage.userMessages.length}`);
        debugStorage(`current botMessages storage: ${this.storage.botMessages.length}`);
        this.storage.botMessages = this.storage.botMessages.filter(this.messageFilter, this);
        debugStorage(`filtered botMessages storage: ${this.storage.botMessages.length}`);
    }
    cleanUpDaemon() {
        if (!this.started) {
            return;
        }
        this.cleanUpDaemonInterval = setInterval(this.cleanUp.bind(this), this.config.storeTimeout);
    }
    getUpdatesHistory(token) {
        return [...this.storage.botMessages, ...this.storage.userMessages]
            .filter((item) => item.botToken === token)
            .sort((a, b) => a.time - b.time);
    }
    getUpdates(token) {
        const messages = this.storage.userMessages.filter((update) => update.botToken === token && !update.isRead);
        return messages.map((update) => {
            update.isRead = true;
            return TelegramServer.formatUpdate(update);
        });
    }
    async start() {
        this.server = (0, http_shutdown_1.default)(http_1.default.createServer(this.webServer));
        await new Promise((resolve, reject) => {
            this.server.listen(this.config.port, this.config.host)
                .once('listening', resolve)
                .once('error', reject);
        });
        debugServer(`Telegram API server is up on port ${this.config.port} in ${this.webServer.settings.env} mode`);
        this.started = true;
        this.cleanUpDaemon();
    }
    removeUserMessage(updateId) {
        this.storage.userMessages = this.storage.userMessages.filter((update) => update.updateId !== updateId);
    }
    removeBotMessage(updateId) {
        this.storage.botMessages = this.storage.botMessages.filter((update) => update.updateId !== updateId);
    }
    setWebhook(webhook, botToken) {
        this.webhooks[botToken] = webhook;
        debugServer(`Webhook for bot ${botToken} set to: ${webhook.url}`);
    }
    deleteWebhook(botToken) {
        delete this.webhooks[botToken];
        debugServer(`Webhook unset for bot ${botToken}`);
    }
    deleteMessage(chatId, messageId) {
        const isMessageToDelete = (update) => {
            let messageChatId;
            if ('callbackQuery' in update) {
                messageChatId = update.callbackQuery.message.chat.id;
            }
            else if ('chat' in update.message) {
                messageChatId = update.message.chat.id;
            }
            else {
                messageChatId = Number(update.message.chat_id);
            }
            return messageChatId === chatId && update.messageId === messageId;
        };
        const userUpdate = this.storage.userMessages.find(isMessageToDelete);
        if (userUpdate) {
            this.removeUserMessage(userUpdate.updateId);
            return true;
        }
        const botUpdate = this.storage.botMessages.find(isMessageToDelete);
        if (botUpdate) {
            this.removeBotMessage(botUpdate.updateId);
            return true;
        }
        return false;
    }
    async stop() {
        if (this.server === undefined) {
            debugServer('Cant stop server - it is not running!');
            return false;
        }
        this.started = false;
        if (this.cleanUpDaemonInterval) {
            clearInterval(this.cleanUpDaemonInterval);
        }
        const expressStop = new Promise((resolve) => {
            this.server.shutdown(() => {
                resolve();
            });
        });
        debugServer('Stopping server...');
        this.storage = {
            userMessages: [],
            botMessages: [],
        };
        await expressStop;
        debugServer('Server shutdown ok');
        return true;
    }
    static formatUpdate(update) {
        if ('callbackQuery' in update) {
            return {
                update_id: update.updateId,
                callback_query: {
                    id: String(update.callbackId),
                    from: update.callbackQuery.from,
                    message: update.callbackQuery.message,
                    data: update.callbackQuery.data,
                },
            };
        }
        return {
            update_id: update.updateId,
            message: Object.assign(Object.assign({}, update.message), { message_id: update.messageId }),
        };
    }
    static normalizeMessage(message) {
        if ('reply_markup' in message) {
            message.reply_markup = typeof message.reply_markup === 'string'
                ? JSON.parse(message.reply_markup) : message.reply_markup;
        }
        if ('entities' in message) {
            message.entities = typeof message.entities === 'string'
                ? JSON.parse(message.entities) : message.entities;
        }
        return message;
    }
}
exports.TelegramServer = TelegramServer;
